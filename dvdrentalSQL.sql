-- 데이터 조회 --
-- SELECT (칼럼 명) FROM (테이블 명);
select * from customer;

-- 확인 명령
commit;


-- ORDER BY (칼럼 명) : 칼럼을 기준으로 정렬 (오름차순: ASC, 내림차순: DESC )
select
	first_name, last_name, email
from
	customer
order by first_name asc, last_name desc;


-- CREATE TABLE 테이블 명 (칼럼들): 테이블 생성
create table t1(
	id serial not null primary key,
	bcolor varchar,
	fcolor varchar
);


-- INSERT INTO 테이블 명(칼럼 명) VALUES (값);
insert into t1(bcolor, fcolor)
values
	('red', 'red'),
	('red', 'red'),
	('red', null),
	(null, 'red'),
	('red', 'green'),
	('red', 'blue'),
	('green', 'red'),
	('green', 'blue'),
	('green', 'green'),
	('blue', 'red'),
	('blue', 'blue'),
	('green', 'green');


-- DISTINCT (칼럼 명): 칼럼을 기준으로 중복 제거
select distinct bcolor, fcolor
from t1 order by bcolor, fcolor;

select distinct on(bcolor) bcolor, fcolor -- DISTINCT ON(칼럼) : 칼럼을 기준으로 중복을 제거 하고 밖의 칼럼들을 보여준다.
from t1 order by bcolor, fcolor desc;

----------------------------------
-- 필터링 --

-- WHERE 조건  = 조건을 기준으로 필터링
--			 = 집합을 가져올 때 무슨 집합을 가져올 것인간에 대한 조건 지정
select last_name, first_name
from customer
where first_name = 'Jamie';

select last_name, first_name
from customer
where first_name = 'Jamie' and last_name = 'Rice';

select customer_id, amount, payment_date
from payment
where amount <=1 or amount > 8;


-- limit = 특정 집합 출력 시 출력 레코드의 수를 한정, 부분 범위 처리시 사용
-- offset = 뒤의 숫자만큼 띄어서 레코드 출력
select film_id, title, release_year
from film
order by film_id limit 5 offset 120;

select film_id, title, rental_rate
from film
order by rental_rate desc limit 10;


-- fetch = 특정 집합을 출력 시 출력 행의 수를 한정
select film_id, title
from film
order by title
offset 5 rows
fetch first 5 row only;
commit;


-- in 연산자 = 특정 집합(칼럼 or 리스트)에서 특정 집합 or 리스트가 존재하는 지 판단
select customer_id, rental_id, return_date
from rental
where customer_id in(1,2) -- in, not in
order by return_date desc; 


--cast = 형병환
select customer_id, return_date
from rental
where cast(return_date as date) = '2005-05-27';


-- 서브 쿼리 맛보기 = 집합 안의 집합
select first_name, last_name
from customer
where customer_id in (
	 select customer_id
	 from rental
	 where cast(return_date as date) = '2005-05-27'
);


-- between 연산자 = 특정 집합에서 컬럼의 값이 특정 범위 안에 들어가는 집합을 출력
select customer_id, payment_id, amount, payment_date
from payment
where cast(payment_date as date)
	between '2007-02-07' and '2007-05-23';

select customer_id, payment_id, amount, payment_date
from payment
where to_char(payment_date, 'yyyy-mm-dd')
	between '2007-02-07' and '2007-05-23';
	

-- like 연산자 = 특정 집합에서 어떤 칼럼의 값이 특정 값과 유사한 패턴을 갖는 집합을 출력
select first_name, last_name
from customer
where first_name like 'Jen%';

select 'FOO' like 'FOO', 'FOO' like 'F%', 'FOO' like '_O_', 'BAR' like 'B#'; -- %:임의의 글자, _: 임의의 한 글자

select first_name, last_name 
from customer
where first_name like '_her%';


-- is null = 특정 값이 null인지 판단하는 연산자 (is null, is not null)
--test를 위한 전처리
create table contacts(
	id int generated by default as identity, -- 자동 증가
	first_name varchar(50) not null,
	last_name varChar(50) not null,
	email varChar(255) not null,
	phone varChar(15),
	primary key(id) --고유 키 지정
);commit;

insert into contacts(first_name, last_name, email, phone)
values
	('Minsung', 'Kim', 'minsung.kim@sample.com', null),
	('Lily', 'Bush', 'bush@exam.com', '(608-234-2764)');
commit;

select id, first_name, last_name, email, phone
from contacts
where phone is null; -- phone = null은 통하지 않음



-- 실습문제 1 --
-- payment 테이블의 단일 거래 중 amount의 액수 가장 많은 고객들을 추출

select distinct (a.customer_id), a.amount from payment a -- 조건에 맞는 커스텀 id를 추출 
where a.amount = (
	select a.amount from payment a
	order by a.amount desc limit 1 -- 제일 높은 amount 값 하나 추출
);commit;

-- 실습문제 2 --
-- 고객들에게 단체 이메일을 전송할 것이다. customer 테이블에서 고객의 이메일 주소를 추출하고, 단 이메일 형식에 맞지 않는 주소는 제외시킨다.(@존재, @로 시작x, 끝x)

select first_name, last_name, email from customer
where email like '_%@%_' and email is not null;



-- 데이터 타입 --

-- boolean : true, false, 't', 'f', 'true', 'false', 'y', 'n', 'yes', 'no', '1', '0';
create table stock_availability(
	product_id int not null primary key,
	available boolean not null
);
insert into stock_availability(product_id, available)
values
(100,TRUE),(200,FALSE),(300,'t'),(400,'1'),
(500,'y'),(600,'yes'),(700,'no'),(800,'0');  commit;

select * from stock_availability
where available = 'yes';

-- char, varchar, text
create table character_test(
	id serial primary key,
	x char(3),
	y varchar(10),
	z text
); commit;

insert into character_test
values (1,'Y', 'YES I AM', 'YES THEY ARE'), (2, 'Y', 'Y', 'Y'); commit;

select * from character_test
where x = y;

-- numeric : 정수, 0, 실수 모두 포함
create table products(
	id serial primary key,
	name varchar not null,
	price numeric (5, 2) --전체 자릿수 5자리, 소수점 2자리
); commit;

insert into products(name, price)
values
	('Phone', 500.215), ('Tablet', 500.214); commit;
select * from products;

insert into products(name, price)
values
	('공기청정기', 1000); commit; -- 오류 : 자릿수가 5-2인 3자릿수 이여야 한다.
	
	
-- integer : smallint(2)= -32,768 ~ 32,767  integer(4)= -2,147,483,648 ~ 2,147,483,647  bigint(8)= -,9223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
create table books(
	book_id serial primary key,
	title varchar(255) not null,
	pages smallint not null check(pages > 0) -- 조건이 틀리면 거부
); commit;
create table cities(
	city_id serial primary key,
	city_name varchar(255) not null,
	population int not null check(population >= 0)
); commit;


-- serial : auto increment, sequence data
create table table_name( -- 1
	id serial
);
insert into table_name
values (default); commit;
select * from table_name;
drop table table_name; commit;
-----------------------
create sequence table_name_id_seq; -- 2
create table table_name(
	id integer not null default
	nextval('table_name_id_seq') -- 다음 레코드를 시퀀스 형태로 증가
);
alter sequence table_name_id_seq owned by table_name.id; --alter: 수정 명령어, owned by: 소유자
insert into table_name values(default);
commit;
select * from table_name;

create table fruits(
	id serial primary key,
	name varchar not null
);

insert into fruits(name) values('orange');
insert into fruits(id, name) values(default, 'apple');
select * from fruits;
select currval(pg_get_serial_sequence('fruits', 'id')); -- currval: 현재 값 출력 


-- date, time, timestamp : 
select now()::date;
select current_date;
select to_char(now()::date, 'dd/mm/yyyy');
select to_char(now()::date, 'mon dd, yyyy');

select first_name, last_name, 
	now() - create_date as diff
from customer;

select first_name, last_name,
	age(create_date) as age
from customer;

select first_name, last_name,
	extract(year from create_date) as year, -- extract : 날짜, 시간 등을 검색
	extract(month from create_date) as month,
	extract(day from create_date) as day
from customer;

select current_time;
select localtime;

select localtime,
	extract(hour from localtime) as hour, -- extract : 날짜, 시간 등을 검색
	extract(minute from localtime) as minute,
	extract(second from localtime) as second;

select localtime,
	localtime + interval '2hours' as plus_2hours, -- interval : 시간 저장,조작
	localtime - interval '2hours' as minus_2hours;

select now();
select current_timestamp;
select timeofday();
select to_char(current_timestamp,'yyyy'),
	to_char(current_timestamp,'yyyy-mm'),
	to_char(current_timestamp,'yyyy-mm-dd'),
	to_char(current_timestamp,'yyyy-mm-dd hh24'),
	to_char(current_timestamp,'yyyy-mm-dd hh23,mi'),
	to_char(current_timestamp,'yyyy-mm-dd hh24:mi:ss'),
	to_char(current_timestamp,'yyyy-mm-dd hh24:mi:ss.ms'),
	to_char(current_timestamp,'yyyy-mm-dd hh24:mi:ss:us');
	

-- 기본키 : 테이블 내의 유일한 값, not null이여야 한다. 즉, 반드시 존재하는 무결성에 대한 제약이다.
create table tb_product_pk_test(
	product_no integer,
	description text,
	product_cost numeric
);
select * from tb_product_pk_test;
alter table tb_product_pk_test 
	add primary key(product_no); -- primary key 지정
	

create table tb_product_pk_test_2(
	name varchar(255)
); commit;
insert into tb_product_pk_test_2(name)
	values('MASO'), ('IBM'), ('APPLE'), ('SAMSUNG');
select * from tb_product_pk_test_2;

alter table tb_product_pk_test_2
	add column id SERIAL primary key;

alter table tb_product_pk_test_2
	drop constraint tb_product_pk_test_2_PKEY; --실행되지 않는다.

-- 외래 키 : foreign key, 자식 테이블의 특정 칼럼이 부모 테이블의 특정 칼럼 값을 참조
create table so_header(
	id serial primary key,
	customer_id integer,
	ship_to varchar(255)
); commit;
select * from so_header;

create table so_items(
	item_id integer not null,
	so_id integer,
	product_id integer,
	qty integer,
	net_price integer,
	primary key(item_id, so_id)
);commit;

alter table so_items  -- 외래 키 추가
	add constraint fk_so_headers_id -- constraint : 특정 칼럼에 제한
	foreign key (so_id) references so_header(id);commit;
	
insert into so_header(customer_id, ship_to)
values 
	(10, '4000 North First Street, CA 95134,USA'),
	(20, '1900 North First Street, CA 95134,USA'),
	(10, '4000 North First Street, CA 95134,USA');
commit;
select * from so_header;

	
insert into so_items(item_id, so_id, product_id, qty, net_price)
values 
	(1,1,1001,2,1000),
	(2,1,1000,3,1500),
	(3,2,1000,4,1500),
	(1,2,1001,5,1000),
	(2,3,1002,2,1700),
	(3,3,1003,4,2000);commit;
select * from so_items;

insert into so_items(item_id, so_id, product_id, qty, net_price)
values (1,4,1001,2,1000); -- error : so_id는 so_header의 외래 키기 때문에 

alter table so_items
	drop constraint fk_so_headers_id;
commit;

create table so_items(
	item_id integer not null,
	so_id integer references so_header(id), --외래 키 설정
	product_id integer,
	qty integer,
	net_price numeric,
	primary key(item_id, so_id)
); commit;


-- check : 특정 칼럼에 대한 들어가는 값을 제한, 업무적으로 절대 들어갈 수 없는 값을 사전에 차단
create table tb_emp_check_test(
	id serial primary key,
	first_name varchar(50),
	last_name varchar(50),
	birth_date date check(birth_date > '1900-01-01'),
	joined_date date check(joined_date > birth_date),
	salary numeric check(salary > 0)
);commit;
select * from tb_emp_check_test;
insert into tb_emp_check_test (first_name, last_name, birth_date, joined_date, salary)
values ('Jhon', 'Doe', '1972-01-01', '2015-07-01', -1000000); --error : 제약 조건

alter table tb_emp_check_test
	add constraint salary_range_check
	check(salary > 0 and salary <= 100000000000);
commit;

alter table tb_emp_check_test
	add constraint name_check
	check(length(first_name) > 0 and length(last_name) > 0);
commit;


-- unique : 테이블 내에서 칼럼값이  유일한 값임을 보장
create table person(
	id serial primary key,
	first_name varchar(50),
	last_name varchar(50),
	email varchar(50),
	unique(email)
);
commit;
insert into person(first_name, last_name, email)
values ('Jhon', 'Doe', 'j.doe@postgresql.com');
select * from person;

insert into person(first_name, last_name, email)
values ('Jhon', 'Doe', 'j.doe@postgresql111.com');
commit;

create table person_unique_index_test(
	id serial primary key,
	first_name varchar(50),
	last_name varchar(50),
	email varchar(50)
);

create unique index -- 유니크 키 추가
	ix_person_unique_index_test_01
on
	person_unique_index_test(email);

insert into person_unique_index_test(first_name, last_name, email)
	values ('Jhon', 'Doe', 'j.doe@postgresql111.com');
select * from person_unique_index_test;


-- not null : 널 값 방지
create table invoice(
	id serial primary key,
	product_id int not null,
	qty numeric not null check(qty > 0),
	net_price numeric check(net_price > 0)
); commit;
insert into invoice(product_id, qty, net_price)
	values (1, 1, 1);
select * from invoice;


--update
create table invoice_update_test(
	id serial primary key,
	product_id int not null,
	qty numeric not null check(qty > 0),
	net_price numeric check(net_price > 0)
); commit;
insert into invoice_update_test(product_id, qty, net_price)
	values (1, 1, 1);
update invoice_update_test
	set product_id = null -- error : 제약 조건 위배
	where product_id = 1;  
	


-- 실습 문제 1 --
-- 영화 애몌 시스템 구축
create table tb_movie_cust( -- 고객 테이블
	cust_id char(10) primary key,
	cust_nm varchar(50) not null,
	sex varchar(6) not null check(sex in ('남자', '여자')),
	birth_date date not null,
	address varchar(200),
	phone_number varchar(13),
	cust_grade char(1) check(cust_grade in ('S', 'A', 'B', 'C', 'D')),
	join_dt date not null check(join_dt <= expire_dt),
	expire_dt date not null default to_date('9999-12-31', 'yyyy-mm-dd')
);

create table tb_movie_resv( -- 예매 테이블
	resv_no char(10) primary key,
	movie_id char(6) not null,
	movie_theater_id char(6) not null,
	cust_id char(10) references tb_movie_cust(cust_id) not null, -- foreign key
	movie_start_time timestamp not null check(movie_start_time < movie_end_time),
	movie_end_time timestamp not null,
	seat_no char(4) not null
);

insert into tb_movie_cust(cust_id, cust_nm, sex, birth_date,
			address, phone_number, cust_grade, join_dt)
	values
		('0001','김민성','남자',to_date('2002-10-11', 'yyyy-mm-dd'),
		'서울 특별시 반','010-1111-1111','S',to_date('2019-01-11', 'yyyy-mm-dd')),
		('0002','김채원','여자',to_date('2000-08-01', 'yyyy-mm-dd'),
		'서울 특별시 반','010-2112-1111','S',to_date('2019-01-11', 'yyyy-mm-dd')),
		('0003','신짱구','남자',to_date('2002-10-11', 'yyyy-mm-dd'),
		'도쿄도 전체','010-1111-1234','D',to_date('2019-01-11', 'yyyy-mm-dd'));
commit;

insert into tb_movie_resv
	values ('9001', '0001', '0010', '0001',
		to_timestamp('2019-05-01 14:00:00', 'yyyy-mm-dd hh24:mi:ss'),
		to_timestamp('2019-05-01 17:30:00', 'yyyy-mm-dd hh24:mi:ss'),
		'a-01'),
		('9002', '0002', '0020', '0001',
		to_timestamp('2019-04-01 14:00:00', 'yyyy-mm-dd hh24:mi:ss'),
		to_timestamp('2019-04-01 17:30:00', 'yyyy-mm-dd hh24:mi:ss'),
		'j-11'),
		('9003', '0003', '0040', '0002',
		to_timestamp('2019-03-01 16:00:00', 'yyyy-mm-dd hh24:mi:ss'),
		to_timestamp('2019-03-01 18:30:00', 'yyyy-mm-dd hh24:mi:ss'),
		'k-08'),
		('9004', '0004', '0050', '0002',
		to_timestamp('2019-03-25 21:00:00', 'yyyy-mm-dd hh24:mi:ss'),
		to_timestamp('2019-03-25 23:30:00', 'yyyy-mm-dd hh24:mi:ss'),
		'c-02'),
		('9005', '0005', '0060', '0003',
		to_timestamp('2018-07-11 15:00:00', 'yyyy-mm-dd hh24:mi:ss'),
		to_timestamp('2018-07-11 17:30:00', 'yyyy-mm-dd hh24:mi:ss'),
		'e-08'),
		('9006', '0006', '0060', '0003',
		to_timestamp('2017-08-15 16:00:00', 'yyyy-mm-dd hh24:mi:ss'),
		to_timestamp('2017-08-15 17:30:00', 'yyyy-mm-dd hh24:mi:ss'),
		'g-08');
commit;


-- 데이터 조작 --
-- insert 
create table link(
	id serial primary key,
	url varchar(255) not null,
	name varchar(255) not null,
	description varchar(255),
	rel varchar(50)
);commit;

insert into link (url, name)
	values ('https://www.google.com', '구글');commit;
insert into link (url, name)
	values ('''https://www.youtube.com''', '''YouTube''');commit;

insert into link (url, name)
	values ('http://www.naver.com', '네이버'),
		('http://www.nate.com', 'Nate'),
		('http://www.bing.com', 'Bing');
commit;

create table link_tmp as
	select * from link where 0 = 1; -- 스키마만 가져오고 데이터는 가져오지 않음
commit;
select * from link_tmp;

insert into link_tmp
	select * from link; -- link의 데이터 가져와서 link_tmp에 복사
commit;

-- update : 테이블에 존재하는 데이터를 수정하는 명령어(동시성)
--update table_name  
--	set column_1 = value1, column_2 = value2
--	where 조건
alter table link add column last_update date; commit;

alter table link alter column last_update set default current_date;
commit;

update link set last_update = default
where last_update is null;
commit;

update link set rel = 'NO DATA';
commit;

update link set description = name;
commit;

select * from link;


-- update join : update 할 때 다른 테이블 내용 참조
create table product_segment(
	id serial primary key,
	segment varchar not null,
	discount numeric (4,2)
); commit;
insert into product_segment(segment, discount)
values 	('Grand Luxury', 0.05),
		('Luxury', 0.06),
		('Mass', 0.1);
commit;

create table product(
	id serial primary key,
	name varchar not null,
	price numeric(10,2),
	net_price numeric(10,2),
	segment_id int not null,
	foreign key(segment_id) references product_segment(id)
); commit;
insert into product(name, price, segment_id)
values ('K5', 804.89, 1),('K7', 228.55, 3),('K9', 366.45, 2),
	('sonata', 145.33, 3),('spark', 551.77, 3),('avante', 261.58, 1),
	('lozte', 519.62, 2),('santafe', 843.31, 1),('tuson', 254.18, 1),
	('trax', 427.78, 2),('orando', 936.29, 1),('ray', 910.34, 1),
	('morning', 208.33, 3),('verna', 985.45, 1),('k8', 941.26, 1),
	('tico', 895.38, 1),('matiz', 575.74, 2),('sportage', 530.64, 2),
	('accent', 892.43, 1),('tosca', 161.71, 3);
commit;
select  * from product;

update product a set net_price = a.price - (a.price * b.discount)
from product_segment b
where a.segment_id = b.id;
commit;


-- delete : 테이블에서 특정 데이터나 모든 데이터 삭제 가능
select * from link;
delete from link
	where id = 5;
commit;

delete from link_tmp a
	using link b
	where a.id = b.id;
select * from link_tmp;

delete from link;
select * from link;
delete from link_tmp; commit;


-- upsert : insert를 할때 조건에 따라 update를 할 수 있다.
create table customers(
	customer_id serial primary key,
	name varchar unique,
	email varchar not null,
	active bool not null default true
); commit;
insert into customers(name, email)
values ('IBM', 'contact@ibm.com'),
	('MicroSoft', 'contact@microsoft.com'),
	('Intel', 'contact@intel.com'); commit;
select * from customers;
insert into customers(name, email)
	values ('MicroSoft', 'hotline@microsoft.com')
	on conflict(name) --conflict : 충돌 시
	do nothing; -- 아무것도 하지 말라.
commit;

insert into customers(name, email)
	values ('MicroSoft', 'hotline@microsoft.com')
	on conflict(name)
	do update --upsert   --excluded : 이메일은 뺀 나머지는 제외
		set email = excluded.email || ';' || customers.email; commit;


-- export : 테이블의 데이터를 다른 형태의 데이터로 추출 :: csv
copy category (category_id, name, last_update)
	to 'c:\tmp\db_category.csv' -- 위치 지정
	delimiter ',' -- 구분자 지정
	csv header; -- 칼럼명 표시 지정
copy category (category_id, name, last_update)
	to 'c:\tmp\db_category.txt' 
	delimiter '	' 
	csv header; 
copy category (category_id, name, last_update)
	to 'c:\tmp\db_category2.csv' 
	delimiter ',' 
	csv;


-- import 
create table category_import(
	category_id serial not null,
	"name" varchar(25) not null,
	last_update timestamp not null default now(),
	constraint category_import_pkey primary key(category_id)
); commit;

copy category_import(category_id, name, last_update) --받기 
	from 'c:\tmp\db_category.csv'
	delimiter ','
	csv header; commit;
copy category_import(category_id, name, last_update) 
	from 'c:\tmp\db_category.txt'
	delimiter '	' --Tab
	csv header; commit;
copy category_import(category_id, name, last_update) 
	from 'c:\tmp\db_category2.csv'
	delimiter ','
	csv; commit;
select * from category_import;


-- 데이터 타입
create table data_type_test_1(
	a_boolean boolean, b_char char(10), c_varchar varchar(10),
	d_text text, e_int int, f_smallint smallint, g_float float,
	h_numeric numeric(15, 2)); commit;
insert into data_type_test_1
	values (true, 'abcde', 'abcde', 'text', 1000, 10, 10.12345, 10.25);
commit;
select * from data_type_test_1;

create table data_type_test_2(
	a_date date, b_time time, c_timestamp timestamp,
	d_array text[], e_json json
); commit;
insert into data_type_test_2
	values (
		current_date, localtime, current_timestamp,
		array['0110-1234-5678', '010+1234+5678'],
		'{"customer":"JHON DOE", "items":{"product": "Beer","qty":6}}'
	);


-- ctas : create table ~~ as ~~
create table action_film as
	select a.film_id, a.title, a.realease_year, a.length, a.rating
		from film a, film_category b 
		where a.film_id = b.film_id and b.category_id = 1;

create table links(
	link_id serial primary key,
	title varchar(512) not null,
	url varchar(1024) not null unique
); commit;

alter table links add column active boolean;
commit;
alter table links drop column active;

alter table links rename column title to link_title;
commit;

alter table links add column target varchar(10);
alter table links alter column target
	set default '_blank';

select * from links;

insert into links(link_title, url)
	values ('PostgreSQL Tutorial', 'http://www.gostgresqltutorial.com/');
commit;

alter table links add check(target in('_self', '_blank', '_parent', '_top'));
commit;

insert into links(link_title, url, target)
	values ('PostgreSQL Tutorial', 'http://www.gostgresqltutorial.com/', 'what'); --Error
commit;


-- 테이블 이름 변경

create table vendors(
	id serial primary key,
	name varchar not null
);
alter table vendors rename to suppliers;
commit;

create table suppliers_groups(
	id serial primary key,
	name varchar not null
);

alter table suppliers add column group_id int not null;
commit;
alter table suppliers add column group_id int not null;
commit;

alter table suppliers add foreign key(group_id)
references suppliers_group(id);

create view supplier_data as
select s.id, s.name, g.name "name"
	from suppliers s, suppliers_groups g 
	where g.id = s.group_id
commit;


-- 칼럼 추가

create table tb_cust(
	cust_id serial primary key,
	cust_name varchar(50) not null
); commit;

alter table tb_cust add column phone_number varchar(13);

alter table tb_cust
	add column fax_number varchar(13),
	add column email_addr varchar(50);
commit;

insert into tb_cust
	values (1, '박준', '0101-1111-1111', '02-2222-5222', 'nice@nice.co.kr');
commit;
alter table tb_cust
	add column contact_nm varchar null;
commit;

update tb_cust
	set contact_nm = '김밥김'
	where cust_id =1;

alter table tb_cust 
	alter column contact_nm set not null;


-- 칼럼 제거
create table publishers (publishers_id serial primary key, name varchar not null);
create table categories
(category_id serial primary key, name varchar not null);
drop table books;
create table books(
	book_id serial primary key,
	title varchar not null,
	isbn varchar not null,
	published_date date not null,
	description varchar,
	category_id int not null,
	publisher_id int not null,
	foreign key (publisher_id) references publishers(publishers_id),
	foreign key (category_id) references categories(category_id)
);
commit;

create view book_info as select 
	b.book_id, b.title, b.isbn, b.published_date, p.name
	from books b, publishers p 
	where p.publishers_id = b.publisher_id
	order by b.title;
commit;

alter table books drop column category_id;
commit;

alter table books drop column publisher_id; --참조 키 지우기 (Error)
commit;

alter table books drop column publisher_id cascade; --관련된 모든 것 삭제
commit;
select * from book_info;

alter table books
	drop column isbn, drop column description;
commit;


--칼럼 데이터 타입 변경
create table assets(
	id serial primary key,
	name text not null,
	asset_no varchar(10) not null,
	description text,
	location text,
	acquired_date date not null
);
insert into assets(name, asset_no, location, acquired_date)
	values ('Server', '1001', 'Server room', '2017-01-01'),
		('ups', '1002', 'Server room', '2017-01-02'); commit;
select * from assets;

alter table assets alter column name type varchar(50); commit; -- 형변환
alter table assets
	alter column location type varchar(50), -- 형 변환 여러개
	alter column description type varchar(500);
commit;

alter table assets alter column asset_no type int; -- Error : 형이 완전히 다르기 때문
alter table assets alter column asset_no type int using asset_no::integer; --casting이 되지 않는 것들은 using 이용


-- 칼럼 이름 변경
drop table customers; commit;

create table customer_groups(
	id serial primary key,
	name varchar not null
); commit;
create table customers (
	id serial primary key,
	name varchar not null,
	phone varchar not null,
	email varchar,
	group_id int,
	foreign key (group_id) references customer_groups(id)
); commit;

create view customer_date as 
	select c.id, c.name, g.name customer_group
		from customers c, customer_groups g 
		where g.id = c.group_id;
commit;

alter table customers
	rename column email to contact_email; commit;
alter table customer_groups
	rename column name to group_name; commit;
	

-- 테이블 제거
create table author(
	author_id int not null primary key,
	firstname varchar(50),
	lastname varchar(50)
); commit;

create table page (
	page_id serial primary key,
	title varchar(255) not null,
	content text,
	author_id int not null,
	foreign key (author_id) references author(author_id)
); commit;

insert into author values (1, 'joono', 'park'); commit;
insert into page values (1, '인공지능', '회귀분석', 1); commit;

drop table author; -- Error : 다른 개체가 의존하고 있어 삭제할 수 없다.
drop table author cascade;
commit;

select * from page;


-- 임시 테이블
create table tb_cust_tmp_test(
	cust_id serial primary key,
	cust_nm varchar not null
);
create temp table tb_cust_tmp_test(cust_id int); --임시 테이블 생성(이름 동일)
commit;
select * from tb_cust_tmp_test; -- 임시 테이블이 보여짐

drop table tb_cust_tmp_test; commit; -- 임시 테이블 삭제
select * from tb_cust_tmp_test; -- 본래 테이블이 보여짐


-- truncate : 대용량의 데이터를 빠르게 삭제


-- 실습문제 1 --
-- dvdrental 시스템의 관리자는 고객별 매출  순위를 알고 싶어 한다.
-- 		신규 테이블을 생성해서 고객의 매출 순위를 관리해라
--		신규 테이블의 이름은 customer_rank 단, 칼럼은 customer_id, custoemr_rank
--		단, ctas기법을 사용하여 테이블을 생성하면서 데이터를 입력해라
	

create table customer_rank as
	select a.customer_id, row_number() over (order by a.sum_amount desc) -- row_number()함수 : 행의 순차 지정 {sum_amount를 내림차순한 번호대로 customer_rank에 입력}
		as customer_rank, sum_amount
			from(
				select a.customer_id, sum(a.amount) as sum_amount -- 고객 번호와 각 고객의 금액 합계
					from payment a group by a.customer_id -- customer_id를 기준으로 집계
				) a -- 이름 지정
			order by customer_rank asc; --rank 오름차순
select * from customer_rank;


-- 실습문제 2 --
--관리자는 매달마다 매출순위 1위를 기록한 고객에게 선물을 주려고 한다.
-- ctas 기법으로 customer_rank_yyyymmdd 테이블을 생성하는 sql를 작성하라
-- sum_amount를 월별로 산출

select a.customer_id, YYYYMM, sum_amount,
	row_number() over (partition by YYYYMM order by sum_amount desc) as rank_YYYYMM --partition : 쪼개다
	from(
		select a.customer_id, to_char(a.payment_date, 'YYYYMM') as YYYYMM, --id, 날짜를 문자열화 시킨 YYYYMM
				sum(a.amount) as sum_amount
			from payment a 
			group by a.customer_id, to_char(a.payment_date, 'YYYYMM') --
	) a
	order by YYYYMM, rank_YYYYMM;

create table customer_rank_yyyymm as
	select a.customer_id, YYYYMM, sum_amount,
		row_number() over (partition by YYYYMM order by sum_amount desc) as rank_YYYYMM --partition : 쪼개다
		from(
			select a.customer_id, to_char(a.payment_date, 'YYYYMM') as YYYYMM, -- id, 날짜를 문자열화 시킨 YYYYMM,
					sum(a.amount) as sum_amount -- id 별 합계
				from payment a 
				group by a.customer_id, to_char(a.payment_date, 'YYYYMM')
		) a
		order by YYYYMM, rank_YYYYMM;
select * from customer_rank_yyyymm;


-- 조인 : 2개 이상의 테이블에 있는 정보 중 사용자가 필요한 집합에 맞게 가상의 테이블처럼 만들어서 보여줌
-- inner join, outer join, self join, full outer join, cross join, natural join
create table basket_a
(id int primary key, fruit varchar(100) not null);
commit;
create table basket_b
(id int primary key, fruit varchar(100) not null); commit;

insert into basket_a (id, fruit)
	values(1,'Apple'),(2,'Orange'),(3,'Banana'),(4,'Cucumber');
commit;
insert into basket_b (id, fruit)
	values(1,'Orange'),(2,'Apple'),(3,'Watermelon'),(4,'Pear');
commit;

select a.id id_a, a.fruit fruit_a, b.id id_b, b.fruit fruit_b
	from basket_a a
	inner join basket_b b
		on a.fruit = b.fruit; -- 조인 조건

select * from customer;
select * from payment;

select a.customer_id, a.first_name, a.last_name, a.email,
		b.amount, b.payment_date
	from customer a 
	inner join payment b
		on a.customer_id = b.customer_id
	where a.customer_id = 2;

select a.customer_id, a.first_name, a.last_name, a.email,
		b.amount, b.payment_date,
		c.first_name as s_first_name, c.last_name as s_last_name
	from customer a 
	inner join payment b
		on a.customer_id = b.customer_id
	inner join staff c
		on b.staff_id = c.staff_id;

-- outer join : left/right 를 기준으로 한 테이블을 출력하고 교집합이 있으면 같이 출력
select a.id as id_a, a.fruit as fruit_a,
		b.id as id_b, b.fruit as fruit_b
	from basket_a a
	left join basket_b b
		on a.fruit = b.fruit;

select a.id as id_a, a.fruit as fruit_a,
		b.id as id_b, b.fruit as fruit_b
	from basket_a a
	left join basket_b b
		on a.fruit = b.fruit
	where b.id is not null;

select a.id as id_a, a.fruit as fruit_a,
		b.id as id_b, b.fruit as fruit_b
	from basket_a a
	right join basket_b b
		on a.fruit = b.fruit;

-- self join
create table employee(
	employee_id int primary key,
	first_name varchar (255) not null,
	last_name varchar (255) not null,
	manager_id int,
	foreign key(manager_id) references employee(employee_id)
	on delete cascade -- 어떤 tuple이 삭제될 때 foreign key로 연결된 tuple 또한 같이 삭제된다
);
insert into employee(employee_id, first_name, last_name, manager_id)
	values (1, 'Windy', 'Hays', null), (2, 'Ava', 'Cristensen', 1),
		(3, 'Hassan', 'Conner', 1), (4, 'Anna', 'Reeves', 2),
		(5, 'Sau', 'Norman', 2), (6, 'Kelsie', 'hays', 3),
		(7, 'Tory', 'Goff', 3), (8, 'Sally', 'Lester', 3); commit;
select * from employee;

select e.first_name || ' ' || e.last_name employee, -- 파이프 라인으로 이름을 합쳐서 출력
		m.first_name|| ' ' || m.last_name manager
	from employee e
	inner join employee m
		on e.manager_id = m.employee_id
	order by manager;

select e.first_name || ' ' || e.last_name employee,
		m.first_name|| ' ' || m.last_name manager
	from employee e
	left outer join employee m
		on e.manager_id = m.employee_id
	order by manager;

select * from film;
select f1.title, f2.title, f1.length
	from film f1
	inner join film f2
		on f1.film_id <> f2.film_id and f1.length = f2.length;
		

-- id는 다르고 렌탈 기간은 같은 영화
select f1.title, f2.title, f1.rental_duration
	from film f1
	inner join film f2
		on f1.film_id <> f2.film_id and f1.rental_duration = f2.rental_duration;
-- 장르는 같고 발표일이 같은 영화
select f1.title, f2.title, f1.release_year
	from film f1
	inner join film f2
		on f1.film_id = f2.film_id and f1.release_year = f2.release_year;
	

-- full outer join : inner, left & right outer join 전부 출력
select * from basket_a;
select * from basket_b;

select a.id id_a, a.fruit fruit_a,
		b.id id_b, b.fruit fruit_b
	from basket_a a
	full outer join basket_b b 
		on a.fruit = b.fruit
	where a.id is not null or b.id is null;

create table if not exists departments(
	department_id serial primary key,
	department_name varchar(255) not null
); commit;
create table if not exists employees(
	employee_id serial primary key,
	employee_name varchar(255),
	department_id integer
); commit;
insert into departments(department_name)
	values('Sales'), ('Marketing'), ('HR'), ('IT'), ('Production');
commit;
insert into employees(employee_name, department_id)
	values ('Bette Nicholson', 1), ('Christian Gable', 1), ('Joe Swank', 2),
		('Fred Coster', 3), ('Sandra Kilmer', 4), ('Julia Mcqueen', null);
commit;

select e.employee_name, d.department_name
	from employees e
	full outer join departments d
		on e.department_id = d.department_id;

select e.employee_name, d.department_name
	from employees e
	full outer join departments d
		on e.department_id = d.department_id
	where e.employee_name is null;

select e.employee_name, d.department_name
	from employees e
	full outer join departments d
		on e.department_id = d.department_id
	where d.department_id is null;


-- cross join : catesian product 연산, 모든 경우의 수 
create table cross_t1(	label char(1) primary key	);
create table cross_t2(	score int primary key	); commit;
insert into cross_t1(label)
	values('A'), ('B'); commit;
insert into cross_t2(score)
	values (1),(2),(3); commit;

select * from cross_t1
	cross join cross_t2;


-- natural join : 칼럼이름이 겹치면 자동 조인
create table categories (
	category_id serial primary key,
	category_name varchar(255) not null
); commit;
create table products (
	product_id serial primary key,
	product_name varchar(255) not null,
	category_id int not null,
	foreign key (category_id) references categories(category_id)
); commit;

insert into categories(category_name)
	values ('Smart Phone'), ('Laptop'), ('Tablet'); commit;
insert into products(product_name, category_id)
	values ('IPhone', 1), ('Samsung Galaxy', 1), ('HP Elite', 2),
		('Lenovo ThinkPad', 2), ('Kindle fire', 3); commit;

select * from products a
	natural join categories b;
 -- 같은 결과를 출력 => 코드의 단편화
select a.category_id, a.product_id,
		a.product_name, b.category_name
	from products a
	inner join categories b
		on (a.category_id = b.category_id);

select * from city a
	natural join country b;

select * from city a
	inner join country b
		on (a.country_id = b.country_id);


-- 기초 집계 데이터 
-- group by : 그룹에 대한 합계, 평균, 카운터 등 계산
select customer_id
	from payment
	group by customer_id; -- 여기선 distinct와 같은 역할(중복을 없애준다.)

select customer_id, sum(amount) as amount_sum
	from payment
	group by customer_id -- customer_id를 기준으로 amount를 더한 amount_sum을 계산
	order by sum(amount) desc;

select customer_id, sum(amount) as amount
	from payment
	group by customer_id
	order by 2 desc; -- 2번째 칼럼을 기준으로 정렬

select staff_id, count(payment_id) as staff_count -- staff_id별로 payment_id를 집계
	from payment
	group by staff_id; -- staff_id를 기준으로


-- having : group by의 결과를 필터링
select customer_id, sum(amount) as amount
	from payment
	group by customer_id
	having sum(amount) > 200; -- 필터링

select * from customer;
select store_id, count(customer_id) as count
	from customer
	group by store_id
	having count(customer_id) > 300;


-- 고급 집계 데이터
-- grouping sets : 여러 개의 union all을 사용하여 결과 추출
create table sales(
	brand varchar not null,
	segment varchar not null,
	quantity int not null,
	primary key(brand, segment) -- 동시 무결성
);

insert into sales(brand, segment, quantity)
	values ('abc', 'premium', 100),('abc', 'basic', 200),
		('xyz', 'premium', 100),('xyz', 'basic', 300);

select brand, segment, sum(quantity)
	from sales
	group by brand, segment;

select brand, sum(quantity)
	from sales
	group by brand;

select sum(quantity)
	from sales;

select brand, segment, sum(quantity) -- union all : 합집합을 중복을 포함하여 출력
	from sales
	group by brand, segment
	union all
		select brand, null, sum(quantity)
			from sales
			group by brand
	union all
		select null, segment, sum(quantity)
			from sales
			group by segment
	union all
		select null, null, sum(quantity)
			from sales;

select brand, segment, sum(quantity)
	from sales
	group by 
	grouping sets( -- group by절에 여러개의 그룹을 제시
		(brand, segment),
		(brand),
		(segment),
		()
	);

select grouping(brand) grouping_brand, -- 1이면 그룹핑, 0이면 논그룹핑
		grouping(segment) grouping_segment,
		brand, segment, sum(quantity)
	from sales
	group by 
	grouping sets(
		(brand, segment),
		(brand),
		(segment),
		()
	);


-- roll up : 지정된 grouping 칼럼의 소계 생성
select brand, segment, sum(quantity)
	from sales 
	group by rollup(brand, segment)
	order by brand, segment;


-- cube : grouping 칼럼의 다차원 소계
select brand, segment, sum(quantity)
	from sales
	group by cube(brand, segment) -- 모든 경우의 수의 grouping sets 생성
	order by brand, segment;

select brand, segment, sum(quantity)
	from sales
	group by brand , cube(segment)
	order by brand, segment;

-- 분석함수 : 
create table product_group(
	group_id serial primary key,
	group_name varchar(255) not null
);
drop table product;
create table product(
	product_id serial primary key,
	product_name varchar(255) not null,
	price decimal(11, 2), -- numeric과 유사한 데이터 형식
	group_id int not null,
	foreign key (group_id) references product_group(group_id)
);
insert into product_group(group_name)
values ('Smartphone'), ('Laptop'), ('Tablet');
insert into product(product_name, group_id, price)
values ('MicroSoft Lumia', 1, 200), ('HTC One', 1, 400), ('Nexus', 1, 500),
		('IPhone', 1, 900), ('HP Elite', 2, 1200), ('Lenovo ThinkPad', 2, 700),
		('Sony VAIO', 2, 700), ('Dell Vostro', 2, 800), ('IPad', 3, 700),
		('Kindle Fire', 3, 150), ('Samsung Galaxy Tab', 3, 200);

select count(*)	from product;
select count(*) over() , a.* from product a;

select avg(price) from product;

select b.group_name, avg(price) from product a
	inner join product_group b
		on (a.group_id = b.group_id)
	group by b.group_name; -- 그룹 이름을 기준으로 평균 구하기

select a.product_name, a.price, b.group_name,
		avg(a.price) over(partition by b.group_name) -- group_name으로 파티션을 나누어 각각 평균
	from product a
	inner join product_group b
		on (a.group_id = b.group_id);


-- row_number : 순위 메기기
select a.product_name, a.price, b.group_name,
		row_number() over(partition by b.group_name order by a.price) -- group_name으로 나누어 각각 가격이 낮은 순위 메기기(1,2,3,4)
	from product a
	inner join product_group b
		on (a.group_id = b.group_id);
		
select a.product_name, a.price, b.group_name,
		rank() over(partition by b.group_name order by a.price) -- row_number와 다른점 공통 순위가 있다.(1,1,3,4)
	from product a
	inner join product_group b
		on (a.group_id = b.group_id);
	
select a.product_name, a.price, b.group_name,
		dense_rank() over(partition by b.group_name order by a.price)  -- rank와 다른점 공통 순위 다음에 바로 다음 숫자를 사용한다.(1,1,2,3)
	from product a
	inner join product_group b
		on (a.group_id = b.group_id);

	
-- first_value, last_value
select a.product_name, a.price, b.group_name,
		first_value(a.price) -- group_name으로 파티션을 나누어 각각 그룹의 최솟값
			over(partition by b.group_name order by a.price)
			as lowest_price_per_group
	from product a
	inner join product_group b
		on (a.group_id = b.group_id);

select a.product_name, a.price, b.group_name,
		last_value(a.price) -- group_name으로 파티션을 나누어 각각 그룹의 최솟값
			over(partition by b.group_name order by a.price
			range between unbounded preceding and unbounded following)
			as highest_price_per_group
	from product a
	inner join product_group b
		on (a.group_id = b.group_id);


-- lag, lead 합수
select a.product_name, a.price, b.group_name,
		lag(a.price) -- 각 row의 이전 데이터 
			over(partition by b.group_name order by a.price)
			as prev_price,
		a.price - lag(a.price,1) over(partition by b.group_name order by a.price)
			as cur_prev_diff
	from product a
	inner join product_group b
		on (a.group_id = b.group_id);

select a.product_name, a.price, b.group_name,
		lead(a.price) -- 각 row의 다음 데이터 
			over(partition by b.group_name order by a.price)
			as next_price,
		a.price - lead(a.price,1) over(partition by b.group_name order by a.price)
			as cur_next_diff
	from product a
	inner join product_group b
		on (a.group_id = b.group_id);


-- 실습문제 --
-- rental 테이블을 사용하여 년, 년월, 년월일, 전체 각각의 기준으로 rental_id 기준 렌탈이 
--	일어난 횟수를 출력하라 (전체 데이터 기준으로 모든 행을 출력)

select to_char(rental_date, 'yyyy') Y,
		to_char(rental_date, 'mm') M,
		to_char(rental_date, 'dd') D,
		count(rental_id)
	from rental
	group by 
		rollup(to_char(rental_date, 'yyyy'),
			to_char(rental_date, 'mm'),
			to_char(rental_date, 'dd')
		);


-- rental 테이블과 customer 테이블을 사용하여 현재까지 가장 많이 rental한 고객의 id, 렌탈순위, 누적 렌탈 횟수, 이름을 출력
select a.customer_id, 
		row_number() over(order by count(a.rental_id) desc) as rental_rank,
		count(rental_id) rental_count, 
		max(b.first_name) as first_name,
		max(b.last_name) as last_name
	from rental a
	inner join customer b
		on a.customer_id = b.customer_id
	group by a.customer_id order by rental_rank limit 1;